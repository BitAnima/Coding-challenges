"""Reverse Parenthesis
Given a string that contains properly nested parentheses, return the decoded version of the string using the following rules:

All characters inside each pair of parentheses should be reversed.
Parentheses should be removed from the final result.
If parentheses are nested, the innermost pair should be reversed first, and then its result should be included in the reversal of the outer pair.
Assume all parentheses are evenly balanced and correctly nested."""

def decode(s):

    reversed_arr = []
    pila = []
    position = 0 # Se debe guardar la posición en la nueva cadena, no en la original, para evitar borrar valores accidentalmente

    for element in s:
        
        if element != '(' and element != ')':
            reversed_arr.append(element)
            position += 1 # Aumentamos el contador si no se encuentra un paréntesis

        if element == '(':
            pila.append(position) # Se guarda la posición actual de la nueva cadena, no la del elemento por el que está iterando
        if element == ')':
            inicio = pila.pop() # La pila devuelve la última posición almacenada, que corresponde al último paréntesis de apertura detectado
            fin = position
            fragment = reversed_arr[inicio:fin] #Slicing: Extraemos el contenido del fragmento según lo que hay en su posición
            fragment.reverse()

            # Borramos la zona de los paréntesis según su posición
            del reversed_arr[inicio:fin]

            # Insertamos el fragmento en la misma posición donde estaba el paréntesis de apertura:
            reversed_arr[inicio:inicio] = fragment

            position = len(reversed_arr) # Se actualiza la posición después de la modificación
            
    print(f"Reversed array:", ''.join(reversed_arr), "\n")  
    
        
    return ''.join(reversed_arr)


decode("(f(b(dc)e)a)") # "abcdef".
decode("((is?)(a(t d)h)e(n y( uo)r)aC)") # "Can you read this?".
decode("f(Ce(re))o((e(aC)m)d)p") # "freeCodeCamp".